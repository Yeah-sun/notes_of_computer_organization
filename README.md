# notes_of_computer_organization
本人关于计算机organization的笔记
* 第一章: 计算机系统概述
    * 二进制,十进制和十六进制的转换.
    * 程序指令的设计过程和执行过程(初步了解)
    * 冯诺伊曼计算机结构的5个特点
    * 程序的编译过程
    * 计算机系统的三个性能指标
    * 计算机系统的三个性能评估
    * 理解程序员的抽象思想和分层思想
    * 恶补一下电路的基本知识
* 第二章: 总线系统
    * 

* 第三章: 主存储器
* 第四章: 数据的表示和运算
* 第五章: 指令系统
* 第六章: 中央处理器
* 第七章: 输入输出 (I/O) 系统

---
## 1.计算机系统概述
### 1.1 二进制,十进制和十六进制的转换
&emsp;无论是内存还是外存都是二进制进行存储.当把多个位组合起来,在加上某种解释.即赋予不同位的组合以不同的含义(ASCII,unicode).ACSII以8位来表示一个字母或者符号,人为规定,不过实际首位都是0,0作为保留位
&emsp;在计算机为存储器划分存储单元,一般8个位为一个单元,也就是一字节为一个单元.(后面一个单元就是一个地址).
* 二进制转十进制(略)
* 二进制转十六进制(略)
* 十进制转二进制(略)
* 十六进制转二进制(略)
* 人用十进制;存储用二进制;显示用十六进制

(转换是存在误差的)以前写物理的时候总是保留,分析误差,现在终于又一次感受到了误差的魅力.
### 1.2 程序指令(抽象的模型)
#### 设计过程:
&emsp;计算机内部的二进制不仅仅可以代表为ASCII和整数,也可以代表为指令.
常见的指令有:
* 取数指令
* 运算指令
* 存数指令
* 打印指令

一条指令也是二进制组合,常见就是指令操作码和地址码.下面举例,不是真正的操作码:
| 操作码 | 操作类型 |
|--|--|
|0000| 取数操作|
|0001| 存数操作|
|0010| 加法操作|
|0011| 乘法操作|
|0100| 打印操作|

操作码+目的地址+源地址:` 0000 0000 00010010`(假的).
#### 执行过程:
&emsp;CPU与主存中有三条总线:地址总线,控制总线,数据总线.
![](./image/总线.png)
* GPRs是通用寄存器,CPU存放数据的地方.
* PC是程序计数器,用来存储下一条指令的地址.
* IR是指令寄存器,用来存储当前执行的指令.
* MAR是内存地址寄存器,用来接收PC储存的下一条指令的地址和**IR中指令中**的地址.
* MDR是内存数据寄存器,用来接收来自GPRs的数据和来自主存的数据.
* ALU是算术逻辑单元,由CU控制根据IR的指令取GPRs的数据进行运算
* CU是控制单元,所有流程的参与者和管理者.

**分析一个完整过程**:
![](./image/指令过程1.png)
第一个过程(读取其中一个数据):
1. 程序启动,将第一条指令放入PC中(CU控制)
2. PC的指令地址传给MAR(CU控制PC和MAR)
3. MAR通过地址总线把指令地址给主存(CU控制MAR和主存)
4. 主存将地址总线传来的指令地址与对应数据匹配,通过数据总线给MDR(CU控制)
5. MDR把指令传给IR(CU控制MDR和IR)
6. PC中的指令地址自动"+1".
7. CU读取IR中指令的操作码部分,发现是取数指令.把信息通过控制总线给主存
8. CU将IR中源地址给MAR(CU控制MAR和IR)
9. MAR通过地址总线将地址传给主存.
10. 主存根据控制总线和地址总线的数据,将对应地址中的数据通过数据总线传给MDR.
11. MDR根据IR的目的地址将数据传给GPRs(CU控制)

![](./image/指令过程2.png)
第二个过程(读取其中另一个数据):
1. PC的指令地址传给MAR(CU控制PC和MAR)
2. MAR通过地址总线把指令地址给主存(CU控制MAR和主存)
3. 主存将地址总线传来的指令地址与对应数据匹配,通过数据总线给MDR(CU控制)
4. MDR把指令传给IR(CU控制MDR和IR)
5. PC中的指令地址自动"+1".
6. CU读取IR中指令的操作码部分,发现是取数指令.把信息通过控制总线给主存
7. CU将IR中源地址给MAR(CU控制MAR和IR)
8. MAR通过地址总线将地址传给主存.
9. 主存根据控制总线和地址总线的数据,将对应地址中的数据通过数据总线传给MDR.
10. MDR根据IR的目的地址将数据传给GPRs(CU控制)

![](./image/指令过程3.png)
第三个过程(将俩数据相乘)
1. PC的指令地址传给MAR(CU控制PC和MAR)
2. MAR通过地址总线把指令地址给主存(CU控制MAR和主存)
3. 主存将地址总线传来的指令地址与对应数据匹配,通过数据总线给MDR(CU控制)
4. MDR把指令传给IR(CU控制MDR和IR)
5. PC中的指令地址自动"+1".
6. CU读取IR中指令的操作码部分,发现是乘法指令. 
7. CU根据IR的俩个源地址,将GPRs对应的数据传送给ALU,同时让其执行乘法.
8. CU将ALU的结果根据IR的目的地址储存在GPRs对应的位置.

![](./image/指令过程4.png)
第四个过程(将数据存放主存)
1. PC的指令地址传给MAR(CU控制PC和MAR)
2. MAR通过地址总线把指令地址给主存(CU控制MAR和主存)
3. 主存将地址总线传来的指令地址与对应数据匹配,通过数据总线给MDR(CU控制)
4. MDR把指令传给IR(CU控制MDR和IR)
5. PC中的指令地址自动"+1".
6. CU读取IR中指令的操作码部分,发现是存数指令.把指令信息通过控制总线传给主存
7. CU根据IR的源地址,将GPRs对应的数据传送给MDR.
8. CU将IR的目的地址传给MAR
9. MAR将目的地址传给主存
10. MDR将来自GPRs的数据通过数据总线传给主存
11. 主存通过数据总线,控制总线已经地址总线将对应的数据存放对应的地址.

整个过程其实解决了我的疑问:PC为什么是存储下一条指令,PC在什么时间点自动加1.
### 1.3 冯诺伊曼计算机结构的5个特点
#### 1.3.1 计算机由运算器,控制器,存储器,输入设备和输出设备5个基本部件组成
<img src="./image/冯洛伊曼模型.png" style="zoom:80%;" />
运算器是计算机的执行部件(核心部件:ALU 通用寄存器组：GRPs：)

* 算术运算: 加,减,乘,除等
* 逻辑运算: 与,或,非,异或,移位等

存储器用于存放数据和指令

* 主存储器(内存)
* 辅助存储器(外存): 比如硬盘等

输入设备的主要功能：

* 将程序和数据以机器所能识别和接受的信息形式输入计算机
* 键盘，鼠标，扫描仪，摄像机等

输出设备的主要功能：

* 讲计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出
* 显示器，打印机

控制器是计算机的指挥中心，由其指挥各部件自动协调地进行工作

* 程序计数器（pc）

* 指令寄存器 （IR）
* 控制单元 （CU）

现代计算机模型：
<img src="./image/现代计算机模型.png" style="zoom:80%;" />

#### 1.3.23 指令和数据以同等地位存储在存储器中,形式上没有区别,但计算机应能区分它们,指令和数据均二进制代码表示

<img src="./image/指令和数据的关系.png" style="zoom:80%;" />

#### 1.3.4 指令由操作码和操作数组成两部分,操作数可以是多个
![](./image/指令.png)
#### 1.3.5 采用"存储程序"工作方式

​	“存储程序” 基本思想：将事先编制好的程序和原始数据送入存储器后才能执行，一旦程序被启动执行，就无须操作人员干预，计算机会自动逐条执行指令，直至程序执行结束。（非常重要）

### 1.4 程序的编译过程

#### 1.4_1 机器语言，汇编语言，高级语言
<img src="./image/语言.png" style="zoom:67%;" />
<img src="./image/跨平台.png" style="zoom: 80%;" />

#### 1.4_2 汇编器，解释器以及编译器
<img src="./image/编译过程.png" style="zoom:80%;" />

1. 预处理：将我们的头文件替换成相应文件的代码 gcc -E hello.c -o hello.i
2. 编译：将高级语言转换为汇编语言
3. 汇编：将汇编语言转换成二进制代码
4. 链接：将程序的内各个函数相连接

编译器：将高级语言程序一次性翻译成汇编语言或者机器语言目标程序

解释器：将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行

### 1.5 抽象分层思想
<img src="./image/分层.png" style="zoom:80%;" />

  中间的每一层的功能都是利用下面一层提供的基本服务来完成的，每一层为上一层提供更强大的服务。

#### 硬件部分

##### 1.5_1 器件：晶体管

<img src="./image/NMOS.png" style="zoom:80%;" />
<img src="./image/PMOS.png" style="zoom:80%;" />

原理是给栅极施加电压：

|      |  高压  |  低压  |
| ---- | :----: | :----: |
| NMOS |  导通  | 不导通 |
| PMOS | 不导通 |  导通  |

##### 1.5_2 逻辑电路：与或非

<img src="./image/逻辑非.png" style="zoom:50%;" />
<img src="./image/逻辑与.png" style="zoom:50%;" />
<img src="./image/逻辑或.png" style="zoom:50%;" />
<img src="./image/逻辑异或.png" style="zoom:50%;" />

##### 1.5_3 功能部件

* 主存储器，CPU（全加器，乘法器，控制器），IO设备等

* 这些功能部件是由他的下面一层来实现的，机组也是学习这个功能部件

#### 软件部分

##### 1.5_4 操作系统

* 进程，地址空间，文件等
* 操作系统是存放在硬盘当中，启动时放入我们的主存
* CMD也是存放在我们的硬盘中，其他程序也是一样

demo过程理解:
<img src="./image/demo.png" style="zoom:67%;" />

1. 先操作系统加载进主存
2. 再CMD加载进主存
3. 执行CMD命令启动hello.exe程序
4. hello.exe加载进主存
5. hello.exe系统调用操作系统来完成任务
6. 操作系统来统一调用硬件软件资源

##### 1.5_5 应用，算法与数据结构，编程语言

* 应用实现需要分析处理成算法与数据结构，使用编程语言进行实现。

* 编程语言基于操作系统提供的服务来实现我们的应用。

#### 俩个体系结构

<img src="./image/体系结构.png" style="zoom:50%;" />

##### 1.5_a 指令集体系结构（ISA）

* 是对指令系统的一种规范或结果规范，是软件和硬件之间的接口
* 1. 定义了一台计算机可以执行的所有指令的集合
    2. 规定了每条指令对应计算机执行什么操作
    3. 指令处理的操作数存放的位置以及操作数类型

##### 1.5_b 微体系结果

* ISA的具体逻辑实现，关注处理器内部的硬件设计和实现细节
* 1. 指令的流水线设计
    2. 加法器采用串行进位方式还是并行进位方式
    3. 存储器的结构（如寄存器堆，Cache的结构）
    4. ..............

##### 同一种ISA可能采用不同的微体系结构来实现

### 1.6 计算机体系结构中的7个伟大思想：

1. 使用抽象分层简化设计
2. 加速经常性事件
3. 通过并行提高性能
4. 通过流水线提高性能
5. 通过预测提高性能
6. 存储层次
7. 通过冗余提高可靠性

#### 软件和硬件是在逻辑功能上是等价的

<img src="./image/软硬件逻辑等价.png" style="zoom: 67%;" />

#### 应用软件和系统软件

* 应用软件：专门为数据处理，科学计算，事务管理，多媒体处理，工程设计以及过程控制等应用所编写的各类程序都称为应用软件。
* 系统软件：包括为有效，安全地使用和管理计算机以及开发和运行应用软件而提供的各种软件。
<img src="./image/软件.png" style="zoom: 50%;" />

### 1.7 计算机系统的三个性能指标
#### 1.7_1 时钟周期(clock cycle)

<img src="./image/CPU时钟周期.png" style="zoom:25%;" >



* 时钟是由设计者根据性能规定的

#### 1.7_2 时钟频率(主频)

<img src="./image/CPU时钟频率.png" style="zoom: 25%;" />

#### 1.7_3 CPI(cycles per instruction)
<img src="./image/CPI.png" style="zoom:25%;" />

#### 1.7_4 CPU执行时间

<img src="./image/CPU执行时间.png" style="zoom:25%;" />

### 1.8 计算机系统的三个性能评估
#### 1.8_1 指令执行速度
<img src="./image/性能评估1.png" style="zoom: 25%;" />
<img src="./image/性能评估1例题.png" style="zoom:25%;" />
<img src="./image/性能评估1.1.png" style="zoom:25%;" />

#### 1.8_2 基准程序

* 基准程序是专门用来进行性能评价的一组程序
* SPEC测试程序集 

* * 整数测试程序集 SPECint
  * 浮点测试程序集 SPECfp
  * CPU性能测试集 (SPEC CPU2000)
  * Web服务器性能测试集 (SPECweb99)

#### 1.8_3 阿姆达尔定律

基本思想:对系统中某个硬件部分,或者软件中的某部分进行更新所带来的系统性能的改进程序,取决于该硬件部分或者软件部分被使用的频率或者其执行时间占总执行时间的比例.
<img src="./image/性能故评3.png" style="zoom:50%;" />